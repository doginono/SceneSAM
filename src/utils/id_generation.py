import numpy as np
import cv2
import torch
import matplotlib.pyplot as plt
import seaborn as sns

from src.utils import backproject, vis


def readDepth(filepath):
    depth = cv2.imread(filepath, cv2.IMREAD_UNCHANGED)
    depth_data = depth.astype(np.float32) / 6553.5
    depth_data = torch.from_numpy(depth_data)
    return depth_data


def createMapping(
    ids1,
    backprojectedSamples,
    zg,
    Depthg,
):
    backprojectedSamples = backprojectedSamples.astype(int)
    # efficient
    # filter out samples outside of image bounds
    condition = (
        (backprojectedSamples[1, :] < 0)
        | (backprojectedSamples[0, :] < 0)
        | (backprojectedSamples[1, :] > 679)
        | (backprojectedSamples[0, :] > 1199)
    )
    filteredIndices = np.where(condition)
    filteredBackProj = backprojectedSamples[:, ~condition]

    if len(filteredBackProj[0]) == 0:
        return -1

    depthg = np.array(Depthg[filteredBackProj[1, :], filteredBackProj[0, :]])
    zg = np.delete(zg, filteredIndices)
    depthCheck = depthg - zg

    # depth check indices
    indices = np.where(abs(depthCheck) < 0.01)
    filteredBackProj = filteredBackProj[:, indices]

    if filteredBackProj.size == 0:
        return -1
    ids1_elements = ids1[filteredBackProj[1, :], filteredBackProj[0, :]]
    array, counts = np.unique(ids1_elements, return_counts=True)

    idMostOccuring = int(array[np.argmax(counts)])
    return idMostOccuring


def readImage(filepath):
    image = cv2.imread(filepath)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    return image


# check one class mapping
# behind or not checkdef create_complete_mapping_of_current_frame(


def update_current_frame(curr_mask, id2id):
    """update curr_mask according to sampleFromCurrentMask

    Args:
        curr_mask (np.array): (W,H) with ids
        id2id (np.array): 1D array where at id2id[i] = value, means that the id i of the current frame has actual id value

    Return:
        np.array (W,H): updated mask
    """
    updated = curr_mask.copy()
    ids = np.unique(curr_mask)
    for id in ids:
        updated[curr_mask == id] = id2id[id]
    return updated


def create_complete_mapping_of_current_frame(
    ids_curr,
    curr_frame_number,
    frame_numbers,
    T,
    K,
    depths,
    segmentations,
    id_counter,
    every_frame=5,
    points_per_instance=5,
    verbose = False
):
    """creates a mapping of the current ids to the actual ids according to the past frames;
    This is implemented in a way, that some of the function arguments can be replaced by the frame_reader class from nice_slam,
    in this frame_reader we can also distiguish whether the id will be generated by SAM on the fly or if we have generated them in advance

    Args:
        ids_curr (_type_): _description_
        curr_frame_number (int): current frame number
        frame_numbers (np.array): frame numbers, which will be used for the backprojection
        T (list): list of extrinsic camera poses
        K (np.array): intrinsic camera matrix
        depths (list): contains all depthspath of the frames
        frames (list): contains all rgb image paths
        segmentations (list): contains all segmentations of seen frames
        id_counter (int): the current smallest free id.
        points_per_instance (int, optional): number of points per instance. Defaults to 5.

    Return:
        np.array (2, #num ids in curr_mask): mapping of the current ids to the actual ids according to the past frames
    """
    map = []
    Tf = T[curr_frame_number]
    depthf = readDepth(depths[curr_frame_number])
    unique_ids = np.unique(ids_curr).astype(int)
    max_id = np.max(unique_ids).astype(int)
    map = None

    
    for num in frame_numbers:
        Tg = T[num]
        # starts counting from 0 so the lenght is 1 more than the actual number of frames
        map_of_frame = np.ones(max_id + 1) * (-1)
        ids_past = segmentations[num // every_frame]
        # this gets overwritten
        depthg = readDepth(depths[num])
        samplesFromCurrentMask = backproject.sample_from_instances(
            ids_curr, np.max(unique_ids) + 1, points_per_instance
        )
        for instance in unique_ids:
            
            uv = samplesFromCurrentMask[:, :, instance]
            
                
            

            backprojectedSamples, zg = backproject.backproject(
                uv, Tf, Tg, K, depthf
            )
            counter = 0
            if verbose and counter <=2 and instance <=2 and num <=2:
                fig, ax = plt.subplots(1, 2)
                ax[0].imshow(ids_past)
                sns.scatterplot(x=uv[0], y=uv[1], ax=ax[1], color = "red")
                ax[0].set_title(f'{num}')
                ax[1].imshow(ids_curr)
                sns.scatterplot(x=backprojectedSamples[0], y=backprojectedSamples[1], ax=ax[0], color = "red")
                ax[1].set_title(f'{num}')
                fig.savefig(f'/home/koerner/Project/nice-slam/src/utils/tmp/{instance}_{counter}_{num}.png')
                counter += 1
            # this overwrites the depthg therefore I calculate it in actual_id # depthg
            actual_id = createMapping(
                ids_past,
                backprojectedSamples,
                zg,
                depthg,
            )
            if actual_id == -1:
                actual_id = id_counter
                id_counter += 1
            map_of_frame[
                instance
            ] = actual_id  # at index i of map_of_frame is the actual id of the instance i in the current frame

        if map is None:
            map = map_of_frame[None]
        else:
            np.concatenate([map, map_of_frame[None]], axis=0)

    map = combineMaps(
        map.T
    )  # at index i of map.T are the actual ids of the instance i according to the past frames
    return map, id_counter


def create_complete_mapping(
    store_path, every_nth_frame, T, K, directory, points_per_instance=5
):
    pass


def combineMaps(map):
    # reduce map on axis 1 end check if all elements are the same or -1
    if map.shape[1] != 1:
        for i in range(map.shape[0]):
            tmp = map[i][map[i] != -1]
            assert ~(np.all(tmp[0] - tmp == 0)), "mapping is not consistent"
    return map.T[0]

def generateIds(masks, min_area=0):
    """sortedMasks = sorted(masks, key=(lambda x: x["area"]), reverse=True)
    ids = np.ones(
        (
            sortedMasks[0]["segmentation"].shape[0],
            sortedMasks[0]["segmentation"].shape[1],
            1,
        )
    )
    # maybe more efficient
    # first frame has 85 instances so not too bad
    for i, ann in enumerate(sortedMasks):
        m = ann["segmentation"]
        idsForEachMask = np.concatenate([[i]])
        ids[m] = idsForEachMask
    return ids.squeeze().astype(np.int32)"""
    sortedMasks = sorted(masks, key=(lambda x: x["area"]), reverse=False)
    if min_area > 0:
        sortedMasks = [mask for mask in sortedMasks if mask["area"] > min_area]
    segmentations = [sortedMasks[i]['segmentation'] for i in range(len(sortedMasks))]
    segmentations = np.array(segmentations)
    non_missing_entries = np.sum(segmentations, axis=0)>0
    segmentations = np.argmax(segmentations, axis=0)
    segmentations[~non_missing_entries] = -2
    return segmentations.astype(np.int32)
    


from backproject import *
import numpy as np
import cv2
import torch

import backproject


def readDepth(filepath):
    depth = cv2.imread(filepath, cv2.IMREAD_UNCHANGED)
    depth_data = depth.astype(np.float32) / 6553.5
    depth_data = torch.from_numpy(depth_data)
    return depth_data

def readImage(filepath):
    image = cv2.imread(filepath)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    return image


# check one class mapping
# behind or not check
def createMapping(
    ids1,
    ids2,
    backprojectedSamples,
    samplesFromCurrentMask,  #
    zg,
    depthG,
    instance=10,
):
    """_summary_

    Args:
        ids1 (_type_): ids from past frame corresponding to depthg
        ids2 (_type_): ids from current frame
        backprojectedSamples (_type_): _description_
        samplesFromCurrentMask (_type_): _description_
        depthG (_type_): _description_
        instance (int, optional): _description_. Defaults to 10.

    Returns:
        _type_: _description_
    """
    points_per_instance = 5
    backprojectedSamples = backprojectedSamples.astype(int)
    # efficient
    # filter out samples outside of image bounds
    condition = (
        (backprojectedSamples[1, :] < 0)
        | (backprojectedSamples[0, :] < 0)
        | (backprojectedSamples[1, :] > 679)
        | (backprojectedSamples[0, :] > 1199)
    )
    filteredBackProj = backprojectedSamples[:, ~condition]

    numOutofBounds = points_per_instance - len(filteredBackProj[0])
    print("numOutofBounds", numOutofBounds)
    mapping = {}
    elementsBackprojected = np.array(
        list(zip(filteredBackProj[0], filteredBackProj[1]))
    )
    elementesCurrentFrame = np.array(
        list(zip(samplesFromCurrentMask[0], samplesFromCurrentMask[1]))
    )

    depthCheck = depthG - zg
    print("depthCheck", depthCheck)
    indices = np.where(abs(depthCheck) > 0.01)
    numOfUnseenEarlier = len(indices)

    elementsBackprojected = elementsBackprojected[indices]
    elementesCurrentFrame = elementesCurrentFrame[indices]

    ids1_elements = ids1[elementsBackprojected[:, 1], elementsBackprojected[:, 0]]
    ids2_elements = ids2[elementesCurrentFrame[:, 1], elementesCurrentFrame[:, 0]]
    array, counts = np.unique(ids1_elements, return_counts=True)
    idMostOccuring = array[np.argmax(counts)]

    if np.max(counts) > numOutofBounds + numOfUnseenEarlier:
        return int(idMostOccuring)
    return -1


def update_current_frame(curr_mask, id2id):
    """update curr_mask according to sampleFromCurrentMask

    Args:
        curr_mask (np.array): (W,H) with ids
        id2id (np.array): 1D array where at id2id[i] = value, means that the id i of the current frame has actual id value

    Return:
        np.array (W,H): updated mask
    """
    ids = np.unique(curr_mask)
    for id in ids:
        curr_mask[curr_mask == id] = id2id[id]
    return curr_mask


def create_complete_mapping_of_current_frame(ids_curr, curr_frame_number, frame_numbers, T,K, depths, segmentations, id_counter, points_per_instance=5):
    """createsa mapping of the current ids to the actual ids according to the past frames; 
    This is implemented in a way, that some of the function arguments can be replaced by the frame_reader class from nice_slam,
    in this frame_reader we can also distiguish whether the id will be generated by SAM on the fly or if we have generated them in advance

    Args:
        ids_curr (_type_): _description_
        curr_frame_number (int): current frame number
        frame_numbers (np.array): frame numbers, which will be used for the backprojection
        T (list): list of extrinsic camera poses
        K (np.array): intrinsic camera matrix
        depths (list): contains all depthspath of the frames
        frames (list): contains all rgb image paths
        segmentations (list): contains all segmentations of seen frames
        id_counter (int): the current smallest free id.
        points_per_instance (int, optional): number of points per instance. Defaults to 5.
        
    Return:
        np.array (2, #num ids in curr_mask): mapping of the current ids to the actual ids according to the past frames
    """
    map = []
    Tf = T[curr_frame_number]
    depthf = readDepth(depths[curr_frame_number])
    unique_ids = np.unique(ids_curr)
    max_id = np.max(unique_ids)
    map = None

    for num in frame_numbers:
        Tg = T[num]
        map_of_frame = np.ones(max_id) * (-1)
        ids2 = segmentations[num]
        depthg = readDepth(depths[num])

        for instance in unique_ids:
            samplesFromCurrentMask = sample_from_instances(
                ids2, len(unique_ids), points_per_instance
            )

            current = samplesFromCurrentMask[:, :, instance]

            backprojectedSamples, zg = backproject.backproject(
                current, Tf, Tg, K, depthf
            )
            actual_id = createMapping(
                ids_curr, num, backprojectedSamples, samplesFromCurrentMask,zg, depthg, instance
            )
            if actual_id == -1:
                actual_id = id_counter
                id_counter += 1
            map_of_frame[instance] = actual_id #at index i of map_of_frame is the actual id of the instance i in the current frame
        
        if map is None:
            map = map_of_frame[None]
        else:
            np.concatenate([map, map_of_frame[None]], axis=0)

    map = combineMaps(
        map.T
    )  # at index i of map.T are the actual ids of the instance i according to the past frames
    return map, id_counter

def create_complete_mapping(store_path, every_nth_frame, T, K, directory, points_per_instance=5):
    pass


def combineMaps(map):
    # reduce map on axis 1 end check if all elements are the same or -1
    for i in range(map.shape[0]):
        tmp = map[i][map[i] != -1]
        assert ~(np.all(tmp[0] - tmp == 0)), "mapping is not consistent"
    return map.T[0]
